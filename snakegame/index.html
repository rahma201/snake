<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Snake – Web Version</title>
    <style>
      :root {
        --hud-bg: rgba(0, 0, 0, 0.5);
        --hud-text: #fff;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        overflow: hidden;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans",
          Tahoma, Arial, sans-serif;
        background: radial-gradient(circle at 30% 30%, #0f9b0f, #000000 70%);
        transition: background 400ms ease-in-out;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
      .hud {
        position: fixed;
        inset: 0 auto auto 0;
        padding: 12px 14px;
        margin: 12px;
        background: var(--hud-bg);
        color: var(--hud-text);
        border-radius: 12px;
        font-weight: 700;
        letter-spacing: 0.3px;
        user-select: none;
        backdrop-filter: blur(4px);
      }
      .overlay {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        background: rgba(0, 0, 0, 0.4);
        color: #fff;
        text-align: center;
        padding: 24px;
      }
      .panel {
        background: rgba(0, 0, 0, 0.6);
        padding: 24px 28px;
        border-radius: 18px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      }
      h1 {
        margin: 0 0 8px;
        font-size: clamp(28px, 6vw, 48px);
      }
      p {
        margin: 6px 0;
        opacity: 0.95;
      }
      .btn {
        display: inline-block;
        margin-top: 12px;
        padding: 10px 16px;
        border-radius: 999px;
        background: #10b981;
        color: #041b11;
        font-weight: 800;
        cursor: pointer;
      }
      .small {
        font-size: 12px;
        opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <div class="hud" id="hud">
      Score: <span id="score">0</span> · Best: <span id="best">0</span>
    </div>
    <div class="overlay" id="start">
      <div class="panel">
        <h1>Snake Game</h1>
        <p>⬆️ ⬇️ ⬅️ ➡️ or WASD to control</p>
        <p>
          Collide with the wall and appear on the opposite side · Each apple =
          <b>5</b> points
        </p>
        <p class="small">
          Background changes every 10 points · Sound effects included
        </p>
        <div class="btn" id="startBtn">Start Game</div>
        <p class="small">Or press Space / Enter</p>
      </div>
    </div>
    <div class="overlay" id="gameover" style="display: none">
      <div class="panel">
        <h1>Game Over</h1>
        <p>Your Score: <span id="finalScore">0</span></p>
        <div class="btn" id="retryBtn">Try Again</div>
        <p class="small">Space / Enter to play again</p>
      </div>
    </div>

    <audio id="background-music" loop>
      <source src="path/to/your/music.mp3" type="audio/mp3" />
      <source src="path/to/your/music.ogg" type="audio/ogg" />
    </audio>

    <script>
      (() => {
        // ====== Helpers: Audio (Web Audio API) ======
        const audioCtx = new (window.AudioContext ||
          window.webkitAudioContext)();
        function beep({
          freq = 440,
          duration = 100,
          type = "sine",
          vol = 0.2,
        }) {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = type;
          osc.frequency.value = freq;
          gain.gain.value = vol;
          osc.connect(gain).connect(audioCtx.destination);
          osc.start();
          setTimeout(() => {
            gain.gain.exponentialRampToValueAtTime(
              0.0001,
              audioCtx.currentTime + 0.05
            );
            osc.stop(audioCtx.currentTime + 0.05);
          }, duration);
        }
        const sfx = {
          eat: () => {
            beep({ freq: 720, duration: 90, type: "square", vol: 0.25 });
          },
          lose: () => {
            beep({ freq: 180, duration: 300, type: "sawtooth", vol: 0.25 });
          },
          move: () => {
            /* optional tick */
          },
        };

        // ====== Canvas & Grid ======
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        let dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
        const CELL = 24; // grid cell in CSS pixels
        let cols = 0,
          rows = 0; // grid size

        function resize() {
          const vw = Math.floor(window.innerWidth);
          const vh = Math.floor(window.innerHeight);
          canvas.style.width = vw + "px";
          canvas.style.height = vh + "px";
          canvas.width = vw * dpr;
          canvas.height = vh * dpr;
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          cols = Math.floor(vw / CELL);
          rows = Math.floor(vh / CELL);
        }
        window.addEventListener("resize", () => {
          resize();
          resetGame(true);
        });
        resize();

        // ====== Game State ======
        const HUD = {
          scoreEl: document.getElementById("score"),
          bestEl: document.getElementById("best"),
          finalEl: document.getElementById("finalScore"),
        };
        let best = Number(localStorage.getItem("snake_best") || 0);
        HUD.bestEl.textContent = best;

        const startOverlay = document.getElementById("start");
        const gameoverOverlay = document.getElementById("gameover");
        document
          .getElementById("startBtn")
          .addEventListener("click", startGame);
        document
          .getElementById("retryBtn")
          .addEventListener("click", startGame);

        let state = "start"; // 'start' | 'playing' | 'gameover'
        let snake, dir, nextDir, food, score, stepMs, acc, wrapWalls;

        const music = document.getElementById("background-music");

        function resetGame(keepOverlay = false) {
          const startX = Math.floor(cols / 2);
          const startY = Math.floor(rows / 2);
          snake = [
            { x: startX, y: startY },
            { x: startX - 1, y: startY },
            { x: startX - 2, y: startY },
          ];
          dir = { x: 1, y: 0 };
          nextDir = { x: 1, y: 0 };
          placeFood();
          score = 0;
          stepMs = 120; // move every X ms
          acc = 0;
          wrapWalls = true; // enter from wall -> exit opposite side
          HUD.scoreEl.textContent = score;
          updateBackground();
          if (!keepOverlay) {
            state = "playing";
            startOverlay.style.display = "none";
            gameoverOverlay.style.display = "none";
            music.play(); // Start music when the game begins
          }
        }

        function startGame() {
          if (audioCtx.state === "suspended") audioCtx.resume();
          resetGame();
        }

        function gameOver() {
          state = "gameover";
          sfx.lose();
          best = Math.max(best, score);
          localStorage.setItem("snake_best", String(best));
          HUD.bestEl.textContent = best;
          HUD.finalEl.textContent = score;
          gameoverOverlay.style.display = "grid";
          music.pause(); // Stop music when game ends
        }

        // ====== Input ======
        const KEYS = {
          ArrowUp: { x: 0, y: -1 },
          ArrowDown: { x: 0, y: 1 },
          ArrowLeft: { x: -1, y: 0 },
          ArrowRight: { x: 1, y: 0 },
          w: { x: 0, y: -1 },
          s: { x: 0, y: 1 },
          a: { x: -1, y: 0 },
          d: { x: 1, y: 0 },
        };
        window.addEventListener(
          "keydown",
          (e) => {
            if (e.code === "Space" || e.code === "Enter") {
              if (state !== "playing") {
                startGame();
              }
              e.preventDefault();
              return;
            }
            if (state !== "playing") return;
            const k = e.key;
            if (KEYS[k]) {
              const nd = KEYS[k];
              if (nd.x !== -dir.x || nd.y !== -dir.y) {
                nextDir = nd;
              }
              e.preventDefault();
            }
          },
          { passive: false }
        );

        // ====== Food ======
        function placeFood() {
          const occ = new Set(snake.map((c) => c.x + "," + c.y));
          let x, y;
          do {
            x = Math.floor(Math.random() * cols);
            y = Math.floor(Math.random() * rows);
          } while (occ.has(x + "," + y));
          food = { x, y };
        }

        // ====== Drawing ======
        function drawCell(x, y, fill) {
          ctx.fillStyle = fill;
          ctx.fillRect(x * CELL, y * CELL, CELL - 1, CELL - 1);
        }
        function clear() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function draw() {
          clear();
          ctx.globalAlpha = 0.06;
          ctx.strokeStyle = "#ffffff";
          for (let i = 0; i <= cols; i++) {
            ctx.beginPath();
            ctx.moveTo(i * CELL + 0.5, 0);
            ctx.lineTo(i * CELL + 0.5, rows * CELL);
            ctx.stroke();
          }
          for (let j = 0; j <= rows; j++) {
            ctx.beginPath();
            ctx.moveTo(0, j * CELL + 0.5);
            ctx.lineTo(cols * CELL, j * CELL + 0.5);
            ctx.stroke();
          }
          ctx.globalAlpha = 1;

          drawCell(food.x, food.y, "#e11d48");

          for (let i = snake.length - 1; i >= 0; i--) {
            const c = snake[i];
            const isHead = i === 0;
            drawCell(c.x, c.y, isHead ? "#111827" : "#6b7280");
          }
        }

        // ====== Background variations (changes every 10 points) ======
        const BGs = [
          "radial-gradient(circle at 30% 30%, #0f9b0f, #000000 70%)",
          "linear-gradient(135deg, #3b82f6, #0f172a 70%)",
          "linear-gradient(135deg, #f59e0b, #1f2937 70%)",
          "linear-gradient(135deg, #8b5cf6, #111827 70%)",
          "linear-gradient(135deg, #ef4444, #0b1020 70%)",
          "linear-gradient(135deg, #14b8a6, #06121a 70%)",
        ];
        function updateBackground() {
          const idx = Math.floor(score / 10) % BGs.length;
          document.body.style.background = BGs[idx];
        }

        // ====== Game Loop ======
        let last = performance.now();
        function loop(now) {
          const dt = now - last;
          last = now;
          if (state === "playing") {
            acc += dt;
            if (acc >= stepMs) {
              acc = 0;
              step();
            }
            draw();
          }
          requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

        function step() {
          dir = nextDir;
          let nx = snake[0].x + dir.x;
          let ny = snake[0].y + dir.y;

          if (wrapWalls) {
            if (nx < 0) nx = cols - 1;
            else if (nx >= cols) nx = 0;
            if (ny < 0) ny = rows - 1;
            else if (ny >= rows) ny = 0;
          }

          if (!wrapWalls && (nx < 0 || nx >= cols || ny < 0 || ny >= rows)) {
            return gameOver();
          }

          for (let i = 0; i < snake.length; i++) {
            if (snake[i].x === nx && snake[i].y === ny) {
              return gameOver();
            }
          }

          snake.unshift({ x: nx, y: ny });

          if (nx === food.x && ny === food.y) {
            score += 5;
            HUD.scoreEl.textContent = score;
            updateBackground();
            sfx.eat();
            placeFood();
            stepMs = Math.max(70, stepMs - 1.2);
          } else {
            snake.pop();
          }
        }

        function showStart() {
          state = "start";
          startOverlay.style.display = "grid";
          gameoverOverlay.style.display = "none";
        }
        showStart();
      })();
    </script>
  </body>
</html>
